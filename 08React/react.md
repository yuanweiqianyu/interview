# React 面试题

## 1. react和vue的区别
* 相同点：
    * 数据驱动页面，提供响应式的试图组件
    * 都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了webComponents规范
    * 数据流动单向，都支持服务器的渲染SSR
    * 都有支持native的方法，react有React native， vue有wexx
* 不同点：
    * 数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
    * 数据渲染：大规模的数据渲染，react更快
    * 使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
    * 开发风格：react推荐做法jsx + inline style把html和css都写在js了
      vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件。

## 2. redux中的reducer（纯函数）
* Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current action）
* 更新state(这个state可以理解为上下累加器的结果）
* 每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身消减'(reduce), 进而返回最新的state,这也就是典型reduce函数的用法：state ->  action ->  state

## 3. react的refs
   refs就想一个逃生窗，允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函数，
   它将接受地城dom元素或组件的已挂在实例，作为第一个参数

## 4. react中的keys
   帮组我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去定位元素，并且操作它

## 5. React的生命周期
http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/
* React 16之后有三个生命周期被废弃(但并未删除)
    * componentWillMount
    * componentWillReceiveProps
    * componentWillUpdate


官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们


目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段


挂载阶段:
* constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义方法绑定this
* getDerivedStateFromProps: static getDerivedStateFromProps(nextProps, prevState),这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用getDerivedStateFromProps
* render: render函数是纯函数，只返回需要渲染的东西，不应该包含其它的业务逻辑,可以返回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
* componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在componentWillUnmount中取消订阅
更新阶段:
* getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
*  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能
* render: 更新阶段也会触发此生命周期
* getSnapshotBeforeUpdate: getSnapshotBeforeUpdate(prevProps, prevState),这个方法在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与componentDidUpdate搭配使用
* componentDidUpdate: componentDidUpdate(prevProps, prevState, snapshot),该方法在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，snapshot，表示之前的props，之前的state，和snapshot。第三个参数是getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate 中统一触发回调或更新状态。

## 6. React 请求应该放在哪个声明周期中
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进行异步请求,避免白屏,其实这个观点是有问题的.

由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 - React继续前进并继续render,没有办法“暂停”渲染以等待数据到达。

而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在 componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染中多次调用.

目前官方推荐的异步请求是在componentDidmount中进行.

如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:

react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount

## 7. React如何进行组件/逻辑复用?

抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
* 高阶组件:
    * 属性代理
    * 反向继承
* 渲染属性
* react-hooks

## 8. React组件通信如何实现? （React组件间通信方式）
* 父组件向子组件通讯: 父组件可以向子组件通过传 props 的方式，向子组件进行通讯
* 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信息，作为参数，传递到父组件的作用域中
* 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信息进行通信
* 跨层级通信: Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言, 对于跨越多层的全局数据通过Context通信再适合不过
* 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入event模块进行通信
* 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维护一个全局状态中心Store,并根据不同的事件产生新的状态
## 9. React子组件向父组件传值
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数据。

## 10. React有哪些优化性能是手段?

## 11. [为什么虚拟DOM会提高性能](https://www.zhihu.com/question/29504639?sort=created)
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的doom操作，从而提高性能
具体实现步骤：
* 用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到文档中
* 当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两棵树差异
* 把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。


**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```

**1. react和vue的区别**
=> 相同点：
1.数据驱动⻚面，提供响应式的试图组件
2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了
webComponents规范
3.数据流动单向，都支持服务器的渲染SSR
4.都有支持native的方法，react有React native， vue有wexx
=> 不同点：
1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的
2.数据渲染：大规模的数据渲染，react更快
3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目
4.开发⻛格：react推荐做法jsx + inline style把html和css都写在js了
vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件
**2. redux中的reducer（纯函数）**
Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current
action）
更新state(这个state可以理解为上下累加器的结果）
每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身
消减'(reduce),
进而返回最新的state,这也就是典型reduce函数的用法：state -> action -> state
复制代码
**3. react的refs**
Refs 允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函
数，
它将接受底层的dom元素或组件的已挂在实例，作为第一个参数，可以在组件中存储它。
复制代码
**4. react中的keys**
帮助我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去
定位元素，并且操作它
复制代码
**React的生命周期**
[http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

#### 5.

```
React 16之后有三个生命周期被废弃(但并未删除)
```
- componentWillMount
- componentWillReceiveProps
- componentWillUpdate
  官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼
  容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们

```
目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段
```
```
挂载阶段:
```
```
constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义
方法绑定this
```
#### •

```
getDerivedStateFromProps:static getDerivedStateFromProps(nextProps, prevState),
这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用
getDerivedStateFromProps
```
#### •

```
render: render函数是纯函数，只返回需要渲染的东⻄，不应该包含其它的业务逻辑,可以返
回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容
```
#### •

```
componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对
canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在
componentWillUnmount中取消订阅
```
#### •

#### 更新阶段:

- getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用
  shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表
  示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不
  会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能

#### •

- render: 更新阶段也会触发此生命周期
  getSnapshotBeforeUpdate:getSnapshotBeforeUpdate(prevProps, prevState),这个方法
  在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表
  示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给
  componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与
  componentDidUpdate搭配使用

#### •

```
componentDidUpdate:componentDidUpdate(prevProps, prevState, snapshot),该方法
在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，
snapshot，表示之前的props，之前的state，和snapshot。第三个参数是
getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，
则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate
中统一触发回调或更新状态。
```
#### •

**6. React 请求应该放在哪个声明周期中**
React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进
行异步请求,避免白屏,其实这个观点是有问题的.

```
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。
当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 -React继续前进并
继续render,没有办法“暂停”渲染以等待数据到达。
```
```
而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在
componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造
成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染
中多次调用.
```
```
目前官方推荐的异步请求是在componentDidmount中进行.
```
```
如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:
```
```
react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount
```
**7. React如何进行组件/逻辑复用?**

```
抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:
```
```
高阶组件:
○ 属性代理
○ 反向继承
```
#### •

#### • 渲染属性

- react-hooks
  组件复用详解⻅组件复用
8. React组件通信如何实现?

### React组件间通信方式:

- 父组件向子组件通讯: 父组件可以向子组件通过传props 的方式，向子组件进行通讯

### 子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此

### props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信

### 息，作为参数，传递到父组件的作用域中

#### •

### 兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信

### 息进行通信

#### •

### 跨层级通信:Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，

### 例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再

### 适合不过

#### •

### 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入

### event模块进行通信

#### •

### 全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维

### 护一个全局状态中心Store,并根据不同的事件产生新的状态

#### •

**9. React子组件向父组件传值**
父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数
据。
复制代码
10. React有哪些优化性能是手段?

### 性能优化的手段很多时候是通用的详情见前端性能优化加载篇

**11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)**
虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操
作，从而提高性能
具体实现步骤：
·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到
文档中
·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两
棵树差异
·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。
**12. diff算法**
1. 把树形结构按照层级分解，只比较同级元素
   2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度
   优先的遍历，这样每个节点都会有一个标记
   3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就
   记录到一个对象里面
   Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进
   行使用
   react只会匹配相同的class的component（这里的class指的是组件的名字）
   合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借
   宿，React检查所有标记dirty的component重新绘制
   4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能
   **13. 简述下flux的思想**
   flux的最大特点，就是数据的‘单向流动’
   1.用户访问View
   2.View发出用户的Action
   3.Dispatcher收到Action,要求state进行相应的更新
   4.store更新后，发出一个‘change’事件后，更新⻚面
   复制代码
   **14. reac性能优化是哪个周期函**
   shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的
   描绘非常消耗性能，
   如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高
   性能
   复制代码
   **15. react怎么划分业务组件和技术组件**
   根据组件的职责通常把组件分为UI组件和容器组件
   UI组件负责UI的呈现，容器组件负责管理数据和逻辑
   两者通过React-redux提供connect方法联系起来
   **16. setState**
   setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状
   态队列
   而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改
   this.state的值
   那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略
   之前修改的state，造成不可预知的错误
   同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state
   同步更新state:
   setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible
   有可能先于数据渲染完毕就执行。
   第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执
   行
   也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步
   例子：componentDidMount() {
   fetch('https://test.com')

```
.then((res) => res.json())
```
```
.then(
(data) => {
this.setState({ data:data });
StatusBar.setNetworkActivityIndicatorVisible(false);
}
```
**17. setState到底是异步还是同步?**

```
先给出答案: 有时表现出异步,有时表现出同步
```
```
setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步
的。
```
#### 1.

```
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步
的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立
⻢拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参
数setState(partialState, callback)中的callback拿到更新后的结果。
```
#### 2.

```
setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件
和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState
的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，
在更新时会对其进行合并批量更新。
```
#### 3.

18. mixin、hoc、render props、react-hooks的优劣如何？

```
Mixin的缺陷：
```
```
组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知
道这种依赖关系）
```
#### •

- 多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）

```
Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your
application, the harder it is to reason about it.），导致复杂度剧增
```
#### •

#### 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

```
难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互
影响
```
#### ○

```
○ 组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
```
```
Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个
Mixin 的输入输出
```
#### ○

#### •

```
HOC相比Mixin的优势:
```
```
HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突
和互相干扰,这就降低了耦合度
```
#### •

```
不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂
度
```
#### •

#### HOC的缺陷:

```
扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate
滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这
个问题
```
#### •

- Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题
- Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本
- 命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性
  不可⻅性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于
  你是黑盒

#### •

```
Render Props优点:
```
- 上述HOC的缺点Render Props都可以解决
  Render Props缺陷:

```
使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无
法做到如此简单
```
#### •

- 嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
  React Hooks优点:
- 简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁
- 解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦
- 组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千
  函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:
  ○ this 指向容易错误
  ○ 分割在不同声明周期中的逻辑使得代码难以理解和维护
  ○ 代码复用成本高（高阶组件容易使代码量剧增）

#### •

```
React Hooks缺陷:
```
- 额外的学习成本（Functional Component 与 Class Component 之间的困惑）
- 写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本

```
破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和
state，每次render()都要重新创建事件处函数）
```
#### •

- 在闭包场景可能会引用到旧的state、props值
- 内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）

```
React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针
对 props change）
```
#### •

```
关于react-hooks的评价来源于官方react-hooks RFC
```
19. 你是如何理解fiber的?

```
React Fiber 是一种基于浏览器的单线程调度算法.
```
```
React 16之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使
用了循环来代替之前的递归.
```
```
Fiber：一种将recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢
复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。
```
```
你对 Time Slice的理解?
```
```
时间分片
```
- React 在渲染（render）的时候，不会阻塞现在的线程
- 如果你的设备足够快，你会感觉渲染是同步的
- 如果你设备非常慢，你会感觉还算是灵敏的
- 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来
- 同样书写组件的方式
  也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果
  呢？

#### 有图表三个图表，有一个输入框，以及上面的三种模式

#### 这个组件非常的巨大，而且在输入框每次**输入东⻄的时候，就会进去一直在渲染。**为了更好

```
的看到渲染的性能，Dan为我们做了一个表。
```
```
我们先看看，同步模式：
```
```
同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树
的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！
```
```
我们再来看看第二种（Debounced模式）：
```
```
Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变
化。
```
```
这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。
```
```
切换到异步模式：
```
#### 异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色

#### 的。

```
时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保
证⻚面的流畅运行.
```
## 20. 谈谈你对Redux的理解

```
使用Redux应该遵循原则：
```
```
使用Redux应该遵循原则：
```
1. 整个应用共享的state应该存储在store的状态数中，store是唯一的
2. state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state
   state的修改规则reducers必须是一个纯函数，不能有副作用
   Redux提供的API
   1 、createStore
   createStore方法的作用就是创建一个Redux store来存放应用中所有的state
   createStore(reducer, [preloadState], [enhancer])
   createStore方法接受三个参数，后面两个是可选参数
   reducer: 参数的类型必须是function
   preloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的
   参数
   enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function
   createStore提供的方法：
   1 、getState()
   返回当前的state
   2 、dispach(action)
   参数action必须是一个对象，且必须含有type字段
   3 、subscribe(listener)
   事件监听
   2 、combineReducers
   combineReducers主要是把多个reducer合并成一个，并且返回一个新的
   reducer函数，该函数接收的参数也是两个state和action
   3 、compose
   主要是在中间件时候使用，合成函数
   compose(applyMiddleware(thunk),
   window.devToolsExtension?
   window.devToolsExtension() : undefined
   )
   4 、applyMiddleware
   5 、bindActionCreator
   bindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直
   接可以出发action的函数

#### 3.

21. redux的工作流程?

```
首先，我们看下几个核心概念：
```
- Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
  State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这
  种时点的数据集合，就叫做State。

#### •

```
Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到
View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应
该要发生变化了。
```
#### •

```
Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，
所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
```
#### •

```
Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种
State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参
数，返回一个新的State。
```
#### •

- dispatch：是View发出Action的唯一方法。
  然后我们过下整个工作流程：
1. 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
   然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer
   会返回新的State

#### 2.

3. State一旦有变化，Store就会调用监听函数，来更新View。
   到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式
   保证了流程的清晰。

```
react-redux是如何工作的?
```
- Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store
  connect: 负责连接React和Redux
  获取state: connect通过context获取Provider中的store，通过store.getState()获取整
  个store tree 上所有state

#### ○

```
包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect
返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件
WrappedComponent，并把connect中传入的mapStateToProps,
mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给
WrappedComponent
```
#### ○

```
监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变
更前state状态进行比较,从而确定是否调用this.setState()方法触发Connect及其子组
件的重新渲染
```
#### ○

#### •

#### 22.

23. redux与mobx的区别?

```
两者对比:
```
- redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
  redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存
  数据，数据变化后自动处理响应的操作

#### •

```
redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新
的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
```
#### •

```
mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；
redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系
列的中间件来处理异步和副作用
```
#### •

```
mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够
进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
```
#### •

#### 场景辨析:

#### 基于以上区别,我们可以简单得分析一下两者的不同使用场景.

```
mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力
不从心.
```
```
redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操
作，由于redux不可变的特性，天然支持这些操作.
```
```
mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.
```
```
当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用
mobx作为组件局部状态管理器来用.
```
24. redux中如何进行异步操作?

```
当然,我们可以在componentDidmount中直接进行请求无须借助redux.
```
```
但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中
间件进行异步处理.
```
```
redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-
saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度
还是npm下载量都比较差了.
```
25. redux异步中间件之间的优劣?

```
redux-thunk优点:
```
- 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简
  单

#### •

```
redux-thunk缺陷:
```
- 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
- 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
- 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:

```
异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js
中
```
#### •

```
action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满
“黑魔法” thunk function
```
#### •

```
异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过
try/catch 语法直接捕获处理
```
#### •

```
功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者
无须封装或者简单封装即可使用
```
#### •

- 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
- 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:

```
额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,
学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-
observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
```
#### •

- 体积庞大: 体积略大,代码近2000行，min版25KB左右
- 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
- ts支持不友好: yield无法返回TS类型
  redux-observable优点:

```
功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你
能想到的异步处理
```
#### •

```
背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而
且随着rxjs的升级redux-observable也会变得更强大
```
#### •

```
redux-observable缺陷:
```
- 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步
  流中间件这个层面redux-saga仍处于领导地位

#### •

1. react和vue的区别
2. redux中的reducer（纯函数）
3. react的refs
4. react中的keys
5. React的生命周期React 请求应该放在哪个声明周期中
6. React 请求应该放在哪个声明周期中
7. React如何进行组件/逻辑复用?
8. React组件通信如何实现?
9. React子组件向父组件传值
10. React有哪些优化性能是手段?
11. 为什么虚拟DOM会提高性能 [http://www.zhihu.com/question/29...](http://www.zhihu.com/question/29...)
12. diff算法
13. 简述下flux的思想
14. reac性能优化是哪个周期函
15. react怎么划分业务组件和技术组件
16. setState
17. setState到底是异步还是同步?
18. mixin、hoc、render props、react-hooks的优劣如何？
19. 你是如何理解fiber的?
20. 谈谈你对Redux的理解
21. redux的工作流程?
22. react-redux是如何工作的?
23. redux与mobx的区别?
24. redux中如何进行异步操作?
25. redux异步中间件之间的优劣?
26. 父子组件的声明周期。
27. setState的过程

#### SSR

```
SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数
据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。
○ 前后端分离 : 前端与服务端隔离，前端动态获取数据，渲染⻚面。
痛点 :
首屏渲染性能瓶颈 :
空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时
间。在这段时间内，⻚面处于空白的状态。
```
#### □

#### §

#### SEO 问题 : 由于⻚面初始状态为空，因此爬虫无法获取⻚面中任何有效数

#### 据，因此对搜索引擎不友好。

#### 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜

#### 索引擎仍然是没有实现。

#### □

#### §

#### ○

#### 最初的服务端渲染，便没有这些问题。但我们不能返璞归真，既要保证现有的前端独

```
立的开发模式，又要由服务端渲染，因此我们使用 React SSR。
原理 :
○ Node 服务: 让前后端运行同一套代码成为可能。
○ Virtual Dom: 让前端代码脱离浏览器运行。
```
#### •

- **条件** : Node 中间层、 React / Vue 等框架。 结构大概如下:

#### 1.

```
开发流程 : (此处以 React + Router + Redux + Koa 为例)
1、在同个项目中， 搭建 前后端部分，常规结构:
§ build
§ public
src
□ client
□ server
```
#### §

#### §

```
2、server 中使用 Koa 路由监听 ⻚面访问:
import * as Router from 'koa-router'
```
```
const router = new Router()
// 如果中间也提供 Api 层
router.use('/api/home', async () => {
// 返回数据
})
```
```
router.get('*', async (ctx) => {
// 返回 HTML
})
复制代码
```
#### §

```
3、通过访问 url 匹配 前端⻚面路由:
// 前端⻚面路由
import { pages } from '../../client/app'
import { matchPath } from 'react-router-dom'
```
```
// 使用 react-router 库提供的一个匹配方法
const matchPage = matchPath(ctx.req.url, page)
复制代码
```
#### §

#### 4、通过⻚面路由的配置进行 数据获取 。通常可以在⻚面路由中增加 SSR 相关

#### 的静态配置，用于抽象逻辑，可以保证服务端逻辑的通用性，如:

```
class HomePage extends React.Component{
public static ssrConfig = {
cache: true,
fetch() {
// 请求获取数据
}
}
}
复制代码
获取数据通常有两种情况:
中间层也使用 http 获取数据，则此时 fetch 方法可前后端共享；
const data = await matchPage.ssrConfig.fetch()
复制代码
```
#### §

```
中间层并不使用 http，是通过一些 内部调用 ，例如 Rpc 或 直接读数据库
等，此时也可以直接由服务端调用对应的方法获取数据。通常，这里需要
在 ssrConfig 中配置特异性的信息，用于匹配对应的数据获取方法。
// ⻚面路由
class HomePage extends React.Component{
public static ssrConfig = {
fetch: {
url: '/api/home',
}
}
}
```
```
// 根据规则匹配出对应的数据获取方法
// 这里的规则可以自由，只要能匹配出正确的方法即可
const controller = matchController(ssrConfig.fetch.url)
```
```
// 获取数据
const data = await controller(ctx)
复制代码
```
#### §

#### §

```
5、创建 Redux store，并将数据dispatch到里面:
import { createStore } from 'redux'
// 获取 Clinet层 reducer
// 必须复用前端层的逻辑，才能保证一致性；
import { reducers } from '../../client/store'
```
```
// 创建 store
const store = createStore(reducers)
```
```
// 获取配置好的 Action
const action = ssrConfig.action
```
```
// 存储数据
store.dispatch(createAction(action)(data))
复制代码
```
#### §

```
6、注入 Store， 调用renderToString将 React Virtual Dom 渲染成 字符串 :
import * as ReactDOMServer from 'react-dom/server'
import { Provider } from 'react-redux'
```
```
// 获取 Clinet 层根组件
import { App } from '../../client/app'
```
```
const AppString = ReactDOMServer.renderToString(
<Provider store={store}>
<StaticRouter
location={ctx.req.url}
context={{}}>
<App />
</StaticRouter>
</Provider>
)
复制代码
```
#### §

```
§ 7、将 AppString 包装成完整的 html 文件格式；
8、此时，已经能生成完整的 HTML 文件。但只是个纯静态的⻚面，没有样式没
有交互。接下来我们就是要插入 JS 与 CSS。我们可以通过访问前端打包后生成
的asset-manifest.json文件来获取相应的文件路径，并同样注入到 Html 中引
用。
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<link href="${cssPath}" rel="stylesheet" />
<body>
<div id="App">${AppString}</div>
<script src="${scriptPath}"></script>
</body>
</html>
`
复制代码
```
#### §

#### 9、进行 数据脱水 : 为了把服务端获取的数据同步到前端。主要是将数据序列化

```
后，插入到 html 中，返回给前端。
import serialize from 'serialize-javascript'
// 获取数据
const initState = store.getState()
const html = `
<!DOCTYPE html>
<html lang="zh">
<head></head>
<body>
<div id="App"></div>
<script type="application/json"
id="SSR_HYDRATED_DATA">${serialize(initState)}</script>
</body>
</html>
`
```
```
ctx.status = 200
ctx.body = html
复制代码
Tips :
这里比较特别的有两点:
使用了serialize-javascript序列化 store， 替代了JSON.stringify，保证数
据的安全性，避免代码注入和 XSS 攻击；
```
#### 1.

2. 使用 json 进行传输，可以获得更快的加载速度；

#### §

```
10、Client 层  数据吸水 : 初始化 store 时，以脱水后的数据为初始化数据，同
步创建 store。
const hydratedEl = document.getElementById('SSR_HYDRATED_DATA')
const hydrateData = JSON.parse(hydratedEl.textContent)
```
```
// 使用初始 state 创建 Redux store
const store = createStore(reducer, hydrateData)
复制代码
```
#### §

#### •

#### 2. 函数式编程

#### 函数式编程是一种 编程范式 ，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础

#### 与边界法则，追求的是 更简洁、可预测、高复用、易测试 。其实在现有的众多知名库中，都蕴含

```
着丰富的函数式编程思想，如 React / Redux 等。
常⻅的编程范式 :
命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做
什么；
```
#### ○

#### ○ 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；

#### 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承

#### 性、多态性；

#### ○

#### 函数式编程

#### § 换成一种更高端的说法，面向数学编程。怕不怕~🥴

#### ○

#### •

#### 函数式编程的理念 :

#### 纯函数 (确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维

#### 护；

#### 优势 :

#### □ 完全独立，与外部解耦；

#### 高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳

#### 定；

#### □

#### □ 可测试性极强；

#### §

#### 条件 :

#### □ 不修改参数；

#### □ 不依赖、不修改任何函数外部的数据；

```
完全可控，参数一样，返回值一定一样: 例如函数不能包含new Date()或者
Math.randon()等这种不可控因素；
```
#### □

#### □ 引用透明；

#### §

```
我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如split /
join / map；
```
#### §

#### ○

#### 函数复合 : 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最

#### 后的目标；

#### 扁平化嵌套 : 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在

#### JS 中，函数也可以当做参数:

```
□ f(g(k(x))): 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；
□ 理想的做法: xxx(f, g, k)(x)
```
#### §

```
结果传递 : 如果想实现上面的方式，那也就是xxx函数要实现的便是: 执行结果在
各个函数之间的执行传递；
这时我们就能想到一个原生提供的数组方法: reduce，它可以按数组的顺
序依次执行，传递执行结果；
```
#### □

```
所以我们就能够实现一个方法pipe，用于函数组合:
// ...fs: 将函数组合成数组；
// Array.prototype.reduce 进行组合；
// p: 初始参数；
const pipe = (...fs) => p => fs.reduce((v, f) => f(v), p)
复制代码
```
#### □

#### §

#### 使用 : 实现一个 驼峰命名 转 中划线命名 的功能:

```
// 'Guo DongDong' --> 'guo-dongdong'
// 函数组合式写法
const toLowerCase = str => str.toLowerCase()
const join = curry((str, arr) => arr.join(str))
const split = curry((splitOn, str) => str.split(splitOn));
```
```
const toSlug = pipe(
toLowerCase,
split(' '),
join('_'),
encodeURIComponent,
);
console.log(toSlug('Guo DongDong'))
复制代码
```
#### §

#### 好处 :

#### □ 隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；

#### □ 只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；

#### □ 可复用性强，任何一个函数单元都可被任意复用和组合；

#### 可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:

```
const log = curry((label, x) => {
console.log(`${ label }: ${ x }`);
return x;
});
```
```
const toSlug = pipe(
toLowerCase,
log('toLowerCase output'),
split(' '),
log('split output'),
join('_'),
log('join output'),
encodeURIComponent,
);
复制代码
Tips:
一些工具纯函数可直接引用lodash/fp，例如curry/map/split等，并不需
要像我们上面这样自己实现；
```
#### □

#### §

#### ○

```
数据不可变性 (immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:
倡导 : 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新
的对象，而不是直接在原对象上修改；
```
#### §

#### 目的 : 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异

#### 常，能有效提高可控性与稳定性；

#### §

```
§ 并不等同于const。使用const创建一个对象后，它的属性仍然可以被修改；
§ 更类似于Object.freeze: 冻结对象，但freeze仍无法保证深层的属性不被串改；
immutable.js: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被
广泛应用，大大提升了性能与稳定性；
trie数据结构:
® 一种数据结构，能有效地深度冻结对象，保证其不可变；
结构共享 : 可以共用不可变对象的内存引用地址，减少内存占用，提
高数据操作性能；
```
#### ®

#### □

#### §

#### ○

#### 避免不同函数之间的 状态共享 ，数据的传递使用复制或全新对象，遵守数据不可变原

#### 则；

#### ○

#### 避免从函数内部 改变外部状态 ，例如改变了全局作用域或父级作用域上的变量值，可

#### 能会导致其它单位错误；

#### ○

#### 避免在单元函数内部执行一些 副作用 ，应该将这些操作抽离成更独立的工具单元；

#### § 日志输出

#### § 读写文件

#### § 网络请求

#### § 调用外部进程

#### § 调用有副作用的函数

#### ○

#### •

#### 高阶函数 : 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:

#### ○ 将逻辑行为进行 隔离抽象 ，便于快速复用，如处理数据，兼容性等；

#### ○ 函数组合 ，将一系列单元函数列表组合成功能更强大的函数；

#### ○ 函数增强 ，快速地拓展函数功能，

#### •

#### 函数式编程的好处 :

#### ○ 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；

#### 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提

#### 高稳定性与健壮性；

#### ○

#### ○ 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；

#### ○ 更易于做单元测试。

#### •

#### 总结 :

#### 函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单

#### 元函数，组合调用操作数据流；

#### ○

#### 它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部

#### / 副作用；

#### ○

#### •

```
Tips:
其实我们很难也不需要在面试过程中去完美地阐述出整套思想，这里也只是浅尝辄止，一些
个人理解而已。博主也是初级小菜⻦，停留在表面而已，只求对大家能有所帮助，轻喷🤣；
我个人觉得: 这些编程范式之间，其实并不矛盾，各有各的 优劣势 。
理解和学习它们的理念与优势，合理地 设计融合 ，将优秀的软件编程思想用于提升我们应
用；
所有设计思想，最终的目标一定是使我们的应用更加 解耦颗粒化、易拓展、易测试、高复
用，开发更为高效和安全 ；
```
#### 1. SSR

#### 2. 函数式编程

```
2020 年 4 月 18 日 星期六 上午10:40
```








