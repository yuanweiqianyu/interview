1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回304
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回304
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A5
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=0
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码200
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:48


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回304
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回304
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A5
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=0
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码200
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:48


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回304
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回304
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A5
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=0
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码200
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:48


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回304
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回304
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A5
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=0
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码200
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:48


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回304
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回304
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A5
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=0
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码200
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:48


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回304
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回304
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A5
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=0
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码200
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:48


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回304
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回304
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A5
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=0
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码200
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:48


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回304
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回304
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A5
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=0
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码200
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:48


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回304
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回304
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A5
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=0
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码200
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:48


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回304
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回304
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A5
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=0
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码200
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:48


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回304
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回304
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A5
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=0
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码200
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:48


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回304
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回304
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A5
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=0
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码200
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:48


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回304
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回304
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A5
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=0
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码200
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:48


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回304
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回304
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A5
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=0
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码200
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:48


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回304
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回304
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A5
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=0
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码200
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:48


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回304
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回304
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A5
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=0
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码200
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:48


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回304
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回304
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A5
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=0
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码200
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:48


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回304
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回304
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A5
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=0
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码200
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:48


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回304
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回304
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A5
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=0
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码200
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:48


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回304
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回304
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A5
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=0
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码200
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:48


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回304
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回304
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A5
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=0
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码200
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%

2020 年 3 月 16 日 星期一 上午11:48


Http:

1. 几种请求方法
2. 状态码
   304 的缓存原理（添加Etag标签.last-modified） 304 网⻚
   上次请求没有更新，节省带宽和开销

## 3.

4. get/post的区别
5. http协议的理解
6. 关于Http 2.0你知道多少？
    7. http1.0 1.1 2.0的区别
8. HTTP和HTTPS
9. 为什么HTTPS安全
10. 如何解决跨域问题
11. JSONP原理
12. 缓存的理解
13. XML和JSON的区别？
14. 说说TCP传输的三次握手四次挥手策略
15. TCP和UDP的区别
16. 常⻅web安全及防护原理
17. XSS原理及防范
18. XSS与CSRF有什么区别吗？
19. Web Worker和webSocket
20. 什么是Etag？
21. Expires和Cache-Control
22. ETag应用:
23. 为什么使用Etag请求头?
24. defer和async
25. 请你谈谈Cookie的弊端
26. 浏览器本地存储
27. web storage和cookie的区别
28. cookie和session的区别：
29. session与token的区别
30. token、cookie、session三者的理解？？？！！！
31. WEB应用从服务器主动推送Data到客户端有那些方式？
32. 异步加载和延迟加载
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
34. GET和POST的区别，何时使用POST？
35. 请解释一下JavaScript的同源策略。
36. 为什么要有同源限制？
37. GET和POST的区别，何时使用POST？
38. ajax的缺点和在IE下的问题？
39. 如何删除一个cookie
40. 说说网络分层里七层模型是哪七层
41. 说说mongoDB和MySQL的区别
42. SSE
43. 前端如何实现即时通讯？
44. 请简单描述http协议的请求报文和响应报文的组成格式

```
Http
```
1. 几种请求方法
   GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE
2. 状态码
- 1xx表示客户端应该继续发送请求
  100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信
  息，表示确认，之后发送具体参数信息
  2xx表示成功的请求
  200 OK 正常返回信息
  201 Created 请求成功并且服务器创建了新的资源
  202 Accepted 服务器已接受请求，但尚未处理
  3xx表示重定向
  301 Moved Permanently 请求的网⻚已永久移动到新位置。
  302 Found 临时性重定向。
  303 SeeOther 临时性重定向，且总是使用 GET 请求新的 URI。
  304 Not Modified 自从上次请求后，请求的网⻚未修改过。
  4xx表示客户端错误
  400 BadRequest 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起
  请求。
  401 Unauthorized 请求未授权。
  403Forbidden 禁止访问。
  404 NotFound 找不到如何与 URI 相匹配的资源。
  406: '请求的格式不可得。',
  410: '请求的资源被永久删除，且不会再得到的。',
  5xx表示服务器错误
  500 InternalServer Error 最常⻅的服务器端错误。
  502: '网关错误。',
  503 ServiceUnavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  504: '网关超时。'
  304的缓存原理（添加Etag标签.last-modified） 304 网⻚上次请求没有更新，节省带宽和
  开销

## 3.

```
1.服务器首先产生Etag,服务器可在稍后使用它来判断⻚面是否被修改。本质上，客户端通过
该记号传回服务器要求服务器验证（客户端）缓存）
2.304是 HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览
器接受到这个状态码会去去找浏览器缓存的文件
3.流程：客户端请求一个⻚面A。服务器返回⻚面A，并在A上加一个Tage客服端渲染该⻚
面，并把Tage也存储在缓存中。客户端再次请求⻚面A
并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该⻚面
自上次客户端请求之后未被修改。直接返回304
```
```
last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最
后修改的时间
客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-
Modified-Since报头，
询问该事件之后文件是否被修改，没修改返回304
```
```
有了Last-Modified，为什么还要用ETag？
1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—
Modified不能识别秒单位的修改）
2、某些服务器不能精确的得到文件的最后修改时间
3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这
个时候我们并不希望客户端认为文件被修改，而重新Get
```
```
ETag，为什么还要用Last-Modified？
1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改
2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。
```
```
ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）
1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。
```
4. get/post的区别
   1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提
   交的数据放在http包的Body中
   2.get提交的数据大小有限制，（因为浏览器对url的⻓度有限制），post的方法提交的数据
   没有限制
   3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量
   的值
   4.get的方法提交数据，会带来安全问题，比如登录一个⻚面，通过get的方式提交数据，用
   户名和密码就会出现在url上
5. http协议的理解
   1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
   2.基于TCP/IP通信协议来传递数据（HTML，图片资源）
   3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
   4.http请求信息request：
   请求行（request line）、请求头部（header）,空行和请求数据四部分构成

```
请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
请求头部，用来说明服务器要使用的附加信息
空行，请求头部后面的空行是必须的
请求数据也叫主体，可以添加任意的其他数据。
5.http相应信息Response
状态行、消息报头、空行和响应正文
```
```
状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
消息报头，用来说明客户端要使用的一些附加信息
空行，消息报头后面的空行是必须的
响应正文，服务器返回给客户端的文本信息。
```
6. 关于Http 2.0你知道多少？
   HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前
   就主动地将数据发送到客户端缓存中，从而提高性能。
   HTTP/2提供更多的加密支持
   HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
   它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的
   header都只会占用很小比例的带宽。
7. http1.0 1.1 2.0的区别
   ⻓连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个⻓连接，而HTP1.1默认支
   持⻓连接
   节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）
   host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端
   口）：HTTP1.0没有host域

```
1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量
3.多路复用：一个连接可以并发处理多个请求
4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客
户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这
种方式非常合适加载静态资源
```
8. HTTP和HTTPS
   HTTP协议通常承载于TCP协议之上
   议，是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，链接则断
   开。
   ，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的
   HTTPS。
   默认HTTP的端口号为80，HTTPS的端口号为443。
9. 为什么HTTPS安全
   因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果
   使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议
   传输。它包含证书，卸载，流量转发，负载均衡，⻚面适配，浏览器适配，refer传递等。
   保障了传输过程的安全性
   如何解决跨域问题
   a. JSONP：
   动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行
   我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。
   由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资
   源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON
   数据并执行回调函数，从而解决了跨域的数据请求。
   优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请
   求。
   b. CORS：
   服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行
   的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
   通过修改document.domain来跨子域
   将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同
   一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行
   跨域
   主域相同的使用document.domain
   c. 使用window.name来进行跨域
   window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,
   窗口载入的所有的⻚面都是共享一个window.name的，每个⻚面对window.name都有
   读写的权限，window.name是持久存在一个窗口载入过的所有⻚面中的
   d. 使用HTML5中新引进的window.postMessage方法来跨域传送数据

## 10.

```
另一个解读: https://github.com/Advanced-Interview-Question/front-end-
interview/blob/dev/docs/guide/browser.md#%E4%BB%80%E4%B9%88%E6%98%
AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%
96%E7%95%A5
更多CORS请看彻底读懂前端跨域CORS
```
11. JSONP原理
    由于浏览器的同源策略限制，不允许跨域请求；但是⻚面中的script、img、iframe标签是
    例外，不受同源策略限制。
    Jsonp 就是利用script标签跨域特性进行请求。
    JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好
    一个同名回调函数名，服务端接收到请求后，将返回一段Javascript，在这段Javascript
    代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网⻚接收到这段
    Javascript 代码后，就会执行这个回调函数。
    JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。
12. 缓存的理解
    缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的
    状态码是 304 。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存
    时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。
1. 强缓存
- Expires
- cache-control
2. 协商缓存
- Last-Modified 和If-Modified-Since
- Etag 和If-None-Match
  更多缓存内容请看前端也要懂Http缓存机制
13. XML和JSON的区别？
    (1).数据体积方面。
    JSON相对于XML来讲，数据的体积小，传递的速度更快些。
    (2).数据交互方面。
    JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
    (3).数据描述方面。
    JSON对数据的描述性比XML较差。
    (4).传输速度方面。
    JSON的速度要远远快于XML。
14. 说说TCP传输的三次握手四次挥手策略
    为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送
    出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过
    程中使用了TCP的标志：SYN和ACK。
    发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK
    标志的数据包以示传达确认信息。
    最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。
    若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。
    断开一个TCP连接则需要“四次握手”：
    § 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就
    是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的
    数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主
    动关闭方还可 以接受数据。
    § 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+
    1（与SYN相同，一个FIN占用一个序号）。
    § 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，
    也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    § 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号
    +1，至此，完成四次挥手。
15. TCP和UDP的区别
    (1)TCP的全称为传输控制协议。这种协议可以提供面向连接的、可靠的、点到点的通信。
    (2)UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。
    (3)用TCP还是UDP，那要看你的程序注重哪一个方面？可靠还是快速？
16. 常⻅web安全及防护原理
    sql注入原理
    就是通过把SQL命令插入到Web表单递交或输入域名或⻚面请求的查询字符串，最终达到欺
    骗服务器执行恶意的SQL命令。
    总的来说有以下几点：
    1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制⻓
    度，对单引号和双"-"进行转换等。
    2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询
    存取。
    3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
    4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

```
1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手
法。也就是说，
在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作
时，会拼接对应参数，
同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。
防范：1.对用户输入进行校验
2.不适用动态拼接sql
2.XSS（跨站脚本攻击）：往web⻚面插入恶意的html标签或者js代码。
举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息
防范：1.尽量采用post而不使用get提交表单
2.避免cookie中泄漏用户的隐式
3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求
举例子：⻩轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来
获取QQ音乐的数据
防范：在客服端⻚面增加伪随机数，通过验证码
XSS和CSRF的区别：
1.XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包
2.CSRF代替用户完成指定的动作，需要知道其他⻚面的代码和数据包
```
## XSS原理及防范

## 首先代码里对用户输入的地方和变量都需要仔细检查⻓度和对”<”,”>”,”;”,”’”等字符

```
做过滤；其次任何内容写到⻚面之前都必须加以encode，避免不小心把html tag 弄出
来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。
```
## 1.

2. 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。
   其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的
   cookie 没有实际价值，不可能拿来重放。

## 3.

```
如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上
HttpOnly 来防止javascript 代码直接获取cookie 。
```
## 4.

## 5. 尽量采用POST 而非GET 提交表单

## 17.

## 18. XSS与CSRF有什么区别吗？

## XSS是获取信息，不需要提前知道其他用户⻚面的代码和数据包。CSRF是代替用户完成指

## 定的动作，需要知道其他用户⻚面的代码和数据包。

## 要完成一次CSRF攻击，受害者必须依次完成两个步骤：

```
登录受信任网站A，并在本地生成Cookie。
在不登出A的情况下，访问危险网站B。
CSRF的防御
§ 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端⻚面增加伪随机
数。
§ 通过验证码的方法
```
```
另一个人的答案:
跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表CSS 混淆，故将跨站脚本攻
击缩写为XSS。恶意攻击者往Web ⻚面里插入恶意Script 代码，当用户浏览该⻚之时，
嵌入其中Web 里面的Script 代码会被执行，从而达到恶意攻击用户的目的。
跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操
作。我们知道，绝大多数网站是通过cookie 等方式辨识用户身份，再予以授权的。所以要
伪造用户的正常操作，最好的方法是通过XSS 或链接欺骗等途径，让用户在本机（即拥有
身份cookie 的浏览器端）发起用户所不知道的请求。
区别：
原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注
入JS代码，然后执行JS里的代码。
```
## ○

```
○ CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录
○ CSRF的目标是用户，XSS的目标是服务器
○ XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求
```
19. Web Worker和webSocket
    worker主线程:Web Worker教程
    1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个
    worker实例。
    2.通过worker.postMessage( data) 方法来向worker发送数据。
    3.绑定worker.onmessage方法来接收worker发送过来的数据。
    4.可以使用 worker.terminate() 来终止一个worker的执行。
    WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个
    Html5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服
    务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。（详细
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#websocket；
    使用指南请看WebSocket 教程）
20. 什么是Etag？
    当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断
    缓存文件是否过期。
    情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器
    控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务
    器没有任何交互的。
    情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和
    Etag
    然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次
    请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没
    有发生变化
    情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的
    内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧——304 Not Modified，
    此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服
    务器之间有一次请求交互。
    情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后
    的操作同①
    ① 只有get请求会被缓存，post请求不会
21. Expires和Cache-Control
    Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires
    头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。
    Cache-Control:no-cache, private, max-age=0
    ETag: abcde
    Expires: Thu, 15 Apr 201420:00:00 GMT
    Pragma: private
    Last-Modified:$now //RFC1123 format
22. ETag应用:
    Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验
    证资源是否修改。常⻅的是使用If-None-Match。请求一个文件的流程可能如下：
    ====第一次请求===
    1.客户端发起 HTTP GET 请求一个文件；
    2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例
    如"2e681a- 6 - 5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码200
    ====第二次请求===
    客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match
    头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a- 6 - 5d0448402.服务器判
    断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返
    回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-
    Control:max-age和Expires呢，怎么办
    答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改
    时间和Etag之后，
    服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
23. 为什么使用Etag请求头?
    Etag 主要为了解决 Last-Modified 无法解决的一些问题。
24. defer和async
    defer并行加载js文件，会按照⻚面上script标签的顺序执行
    async并行加载js文件，下载完成立即执行，不会按照⻚面上script标签的顺序执行
25. 请你谈谈Cookie的弊端
    第一：每个特定的域名下最多生成20个cookie
    1.IE6或更低版本最多20个cookie
    2.IE7和之后的版本最后可以有50个cookie。
    3.Firefox最多50个cookie
    4.chrome和Safari没有做硬性限制
    IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。
    cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。
    IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最
    多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一
    直存在。
    优点：极高的扩展性和可用性
    1.通过良好的编程，控制保存在cookie中的session对象的大小。
    2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
    3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
    4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
    缺点：
    1.`Cookie`数量和⻓度的限制。每个domain最多只能有20条cookie，每个cookie⻓度不能
    超过4KB，否则会被截掉.
    2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也
    与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目
    的了。
    3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存
    一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
26. 浏览器本地存储
    在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了
    localStorage来取代globalStorage。
    html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。
    sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话
    中的⻚面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久
    化的本地存储，仅仅是会话级别的存储。
    而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
27. web storage和cookie的区别
    Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小
    是受限的，并且每次你请求一个新的⻚面的时候Cookie都会被发送过去，这样无形中浪费
    了带宽，另外cookie还需要指定作用域，不可以跨域调用。
    除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要
    前端开发者自己封装setCookie，getCookie。
    但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部
    分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
    浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器
    里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地
    存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。
    localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和
    removeItem等
28. cookie和session的区别：
    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
    考虑到安全应当使用session。
    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
    考虑到减轻服务器性能方面，应当使用COOKIE。
    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个
    cookie。
    5、所以个人建议：
    将登陆信息等重要信息存放为SESSION
    其他信息如果需要保留，可以放在COOKIE中
    display:none和visibility:hidden的区别？
    display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就
    当他从来不存在。
    visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。
29. session与token的区别
    1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认
    证手段。只存在服务端，不能共享到其他的网站和第三方App
    2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的
    就是让某APP有权访问某用户的的信息。Token是唯一的，
    token不能转移到其他的App，也不能转到其他用户上。（适用于App）
    3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客
    户端的
30. token、cookie、session三者的理解？？？！！！
    1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软
    件（最好的身份认证，安全性好，且是唯一的）
    用户身份的验证方式

```
2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网
站，就会自动调用cookie自动登录用户名
服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信
息）
```
```
3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的
就是服务器和客户端的一次会话过程）
cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。
```
31. WEB应用从服务器主动推送Data到客户端有那些方式？
    Javascript数据推送
    § Commet：基于HTTP⻓连接的服务器推送技术
    § 基于WebSocket的推送方案
    § SSE（Server-Send Event）：服务器推送数据新方式
32. 异步加载和延迟加载
    1.异步加载的方案： 动态插入script标签
    2.通过ajax去获取js代码，然后通过eval执行
    3.script标签上添加defer或者async属性
    4.创建并插入iframe，让它异步执行js
    5.延迟加载：有些 js 代码并不是⻚面初始化的时候就立刻需要的，而稍后的某些情况才需
    要的。
33. Flash、Ajax各自的优缺点，在使用中如何取舍？
    § Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜
    索。
- Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。
  § 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM
34. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
35. 请解释一下 JavaScript的同源策略。
    概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自
    Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
    这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。
    指一段脚本只能读取来自同一来源的窗口和文档的属性。
36. 为什么要有同源限制？
    我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录⻚面嵌到他的⻚面上，
    当你使用真实的用户名，密码登录时，他的⻚面就可以通过Javascript读取到你的表单中
    input中的内容，这样用户名，密码就轻松到手了。
    缺点：
    现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严
    格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在
    压缩后浪费了字节。
37. GET和POST的区别，何时使用POST？
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在
    2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form
    来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
    然而，在以下情况中，请使用 POST 请求：
    无法使用缓存文件（更新服务器上的文件或数据库）
    向服务器发送大量数据（POST 没有数据量限制）
    发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
38. ajax的缺点和在IE下的问题？
    详情请⻅：[JavaScript学习总结（七）Ajax和Http状态字][14]
    ajax的缺点
    1、ajax不支持浏览器back按钮。
    2、安全问题 AJAX暴露了与服务器交互的细节。
    3、对搜索引擎的支持比较弱。
    4、破坏了程序的异常机制。
    5、不容易调试。
    IE缓存问题
    在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被
    缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，
    可以通过在URL末尾添加上随机的时间戳参数('t'= + newDate().getTime())
    或者：
    open('GET','demo.php?rand=+Math.random()',true);//
    · 1
    Ajax请求的⻚面历史记录状态问题
    可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时⻚面状态的变化。
    还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变
39. 如何删除一个cookie
    1.将时间设为当前时间往前一点。
    var date = newDate();
    date.setDate(date.getDate() -1);//真正的删除
    setDate()方法用于设置一个月的某一天。
    2.expires的设置
    document.cookie= 'user='+ encodeURIComponent('name') + ';expires = ' +
    newDate(0)
    <strong>，<em>和<b>，<i>标签
    <strong>标签和 <em>标签一样，用于强调文本，但它强调的程度更强一些。
    em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的<i>...</i>;
    < b >< i >是视觉要素，分别表示无意义的加粗，无意义的斜体。
    em 和 strong 是表达要素(phraseelements)。
40. 说说网络分层里七层模型是哪七层
    § 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）
    § 传输层（TCP和UDP）
    § 网络层（IP）
    § 物理和数据链路层（以太网）
    每一层的作用如下：
    物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
    数据链路层：将比特组装成帧和点到点的传递（帧Frame）
    网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
    传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
    会话层：建立、管理和终止会话（会话协议数据单元SPDU）
    表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
    应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
    各种协议
    ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由
    器之间传递控制消息。
    TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协
    议，提供不复杂、开销不大的文件传输服务。
    HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的
    方式，适用于分布式超媒体信息系统。
    DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置
    参数手段。
41. 说说mongoDB和MySQL的区别
    MySQL是传统的关系型数据库，MongoDB则是非关系型数据库
    mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。
    对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，
    MongoDB的优点有：
    ①弱一致性（最终一致），更能保证用户的访问速度：
    ②文档结构的存储方式，能够更便捷的获取数据。
    讲讲304缓存的原理
    服务器首先产生ETag，服务器可在稍后使用它来判断⻚面是否已经被修改。本质上，客户
    端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
    304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状
    态码后，会使用浏览器已缓存的文件
    客户端请求一个⻚面（A）。 服务器返回⻚面A，并在给A加上一个ETag。 客户端展现该⻚
    面，并将⻚面连同ETag一起缓存。 客户再次请求⻚面A，并将上次请求时服务器返回的
    ETag一起传递给服务器。 服务器检查该ETag，并判断出该⻚面自上次客户端请求之后还
    未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
42. SSE
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#sse
43. 前端如何实现即时通讯？
    https://github.com/Advanced-Interview-Question/front-end-
    interview/blob/dev/docs/guide/browser.md#%E5%89%8D%E7%AB%AF%E5%A6%
    82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%B3%E6%97%B6%E9%80%




